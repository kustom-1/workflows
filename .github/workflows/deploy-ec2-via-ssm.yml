# Nombre del archivo: deploy-via-ssm-asg.yml
name: Deploy to EC2 ASG via AWS SSM

on:
  workflow_call:
    inputs:
      # --- Configuración de AWS ---
      aws-region:
        description: 'AWS region of the target Auto Scaling Group'
        required: true
        type: string
      
      # --- Configuración de Destino ---
      asg-name:
        description: 'The name of the target Auto Scaling Group'
        required: true
        type: string
      
      # --- Configuración del Despliegue ---
      deployment-path:
        description: 'Absolute path where the application is located on the EC2 instances'
        required: true
        type: string
      branch:
        description: 'Git branch to pull on the EC2 instances'
        required: false
        type: string
        default: 'main'
      service-name:
        description: 'PM2 service name to restart on the EC2 instances'
        required: true
        type: string

    secrets:
      aws-access-key-id:
        description: 'AWS Access Key ID for deployment'
        required: true
      aws-secret-access-key:
        description: 'AWS Secret Access Key for deployment'
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      # Paso 1: Configurar las credenciales de AWS en el runner
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      # Paso 2: Enviar el script de despliegue a todas las instancias del ASG
      - name: Send Deployment Commands to ASG via SSM
        id: ssm_command
        run: |
          echo "--- Sending deployment script to all instances in ASG: ${{ inputs.asg-name }} ---"
          
          # La clave es --targets, que apunta a las instancias por su etiqueta de ASG
          COMMAND_ID=$(aws ssm send-command \
            --targets "Key=tag:aws:autoscaling:groupName,Values=${{ inputs.asg-name }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploying new version to ${{ inputs.asg-name }}" \
            --parameters 'commands=[
              "#!/bin/bash",
              "set -e",
              "echo --- Starting remote deployment on instance $(hostname) ---",
              "cd ${{ inputs.deployment-path }}",
              "echo --- Pulling latest code from ${{ inputs.branch }} ---",
              "git checkout ${{ inputs.branch }}",
              "git fetch",
              "git pull origin ${{ inputs.branch }}",
              "echo --- Installing dependencies and building application ---",
              "npm ci --production",
              "npm run build",
              "echo --- Restarting application with PM2 ---",
              "pm2 restart ${{ inputs.service-name }} || pm2 start dist/main.js --name ${{ inputs.service-name }}",
              "pm2 save",
              "echo ✓ Deployment completed on this instance."
            ]' \
            --query "Command.CommandId" \
            --output text)

          # Guardar el Command ID para usarlo en el siguiente paso
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          echo "SSM Command sent with ID: $COMMAND_ID"

      # Paso 3: Esperar a que el comando se complete en al menos una instancia
      - name: Wait for SSM Command to Complete
        run: |
          echo "Waiting for command to complete..."
          # Este es un método simple de espera. Para producción, se recomienda
          # un bucle que verifique el estado en todas las instancias.
          sleep 20 # Dar tiempo a que el comando se propague
          
          # Obtener la lista de instancias para verificar el estado de cada una
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:aws:autoscaling:groupName,Values=${{ inputs.asg-name }}" "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_IDS" ]; then
            echo "::error::No running instances found in the ASG."
            exit 1
          fi

          echo "Waiting on instances: $INSTANCE_IDS"
          
          for ID in $INSTANCE_IDS; do
            aws ssm wait command-executed \
              --command-id "${{ steps.ssm_command.outputs.command_id }}" \
              --instance-id "$ID"
          done

          echo "✓ Command execution finished on all instances."

      # Paso 4 (Opcional pero recomendado): Mostrar el resultado para depuración
      - name: Display Command Output
        run: |
          echo "--- Retrieving command output from instances ---"
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:aws:autoscaling:groupName,Values=${{ inputs.asg-name }}" "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text)
            
          for ID in $INSTANCE_IDS; do
            echo "--- Output for instance $ID ---"
            aws ssm get-command-invocation \
              --command-id "${{ steps.ssm_command.outputs.command_id }}" \
              --instance-id "$ID" \
              --query "[StandardOutputContent, StandardErrorContent]" \
              --output text
            echo "-----------------------------------"
          done